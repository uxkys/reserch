<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shape Puzzle with Chakra UI</title>
  <!-- React & ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Emotion (Chakra UIの依存) -->
  <script src="https://unpkg.com/@emotion/react@11.10.8/dist/emotion-react.umd.min.js"></script>
  <script src="https://unpkg.com/@emotion/styled@11.10.8/dist/emotion-styled.umd.min.js"></script>

  <!-- Chakra UI -->
  <script src="https://unpkg.com/@chakra-ui/react@2.6.2/dist/chakra-ui-react.umd.min.js"></script>
  <!-- Icons (任意) -->
  <script src="https://unpkg.com/@chakra-ui/icons@2.0.17/dist/chakra-ui-icons.umd.min.js"></script>

  <style>
    body, html, #root {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #f0f0f0;
    }
    /* 図形のスタイル */
    .shape-item {
      position: absolute;
      width: 30px; height: 30px;
      text-align: center;
      line-height: 30px;
      user-select: none;
      pointer-events: none; /* クリック無効 */
      font-size: 24px;
      font-weight: bold;
    }
    /* レベル＆タイマー部分の上端被りを回避するため、図形配置は余白を確保している */
  </style>
</head>
<body>
<div id="root"></div>

<script>
(function() {
  const {
    ChakraProvider,
    Box,
    Button,
    Text,
    Flex,
    Input,
    NumberInput,
    NumberInputField,
    useToast,
    Modal,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalCloseButton,
    ModalBody,
    ModalFooter,
    SimpleGrid,
    useDisclosure,
    Center,
    HStack,
    VStack,
    Stack
  } = window["chakra-ui-react"];

  // 画面全体を包むメインコンポーネント
  function ChakraPuzzleApp() {
    const toast = useToast();

    // -----------------------------
    // ゲーム関連のステート
    // -----------------------------
    const [isSessionActive, setIsSessionActive] = React.useState(false);
    const [playTime, setPlayTime] = React.useState(3); // デフォルト3分
    const [timeRemaining, setTimeRemaining] = React.useState(playTime * 60);
    const [timerId, setTimerId] = React.useState(null);

    const [isBadUI, setIsBadUI] = React.useState(false);
    const [level, setLevel] = React.useState(1);
    const [totalLevels, setTotalLevels] = React.useState(200);
    const [correctShape, setCorrectShape] = React.useState("");
    const [shapesPos, setShapesPos] = React.useState([]); // 図形配置

    // スタート前にプレイ時間をフォームで設定
    const handlePlayTimeChange = (value) => {
      // NumberInputField から受け取った文字列を数値化
      const val = parseInt(value, 10);
      if (!isNaN(val)) {
        setPlayTime(val);
      }
    };

    // -----------------------------
    // タイマー
    // -----------------------------
    React.useEffect(() => {
      // 残り時間が変化したらチェック
      if (timeRemaining <= 0 && isSessionActive) {
        // 時間切れ
        endSession();
      }
    }, [timeRemaining, isSessionActive]);

    const startTimer = React.useCallback((durationSeconds) => {
      let remain = durationSeconds;
      setTimeRemaining(remain);
      const id = setInterval(() => {
        remain -= 1;
        setTimeRemaining(remain);
        if (remain <= 0) {
          clearInterval(id);
        }
      }, 1000);
      setTimerId(id);
    }, []);

    const stopTimer = React.useCallback(() => {
      if (timerId) {
        clearInterval(timerId);
        setTimerId(null);
      }
    }, [timerId]);

    // -----------------------------
    // ゲーム開始/終了
    // -----------------------------
    const startSession = () => {
      setIsSessionActive(true);
      setLevel(1);
      // 指定のプレイ時間を秒にしてスタート
      const duration = playTime * 60;
      startTimer(duration);

      // レベル1の図形を配置
      generateShapesForLevel(1);
    };

    const endSession = (forced = false) => {
      stopTimer();
      setIsSessionActive(false);
      // ゲーム終了 → 図形をクリア
      setShapesPos([]);
      if (!forced) {
        toast({
          description: "Session Ended",
          status: "info",
          duration: 3000,
          isClosable: true,
          position: "top"
        });
      }
    };

    // リスタート時の処理
    const handleRestart = () => {
      endSession(true);
    };

    // -----------------------------
    // 図形の配置ロジック
    // -----------------------------
    const shapeTypes = ["■", "▲", "●", "★"];

    const generateShapesForLevel = React.useCallback((lvl) => {
      // 正解の図形をランダム選択
      const idx = Math.floor(Math.random() * shapeTypes.length);
      const correct = shapeTypes[idx];
      setCorrectShape(correct);

      // トータル12個配置するとする
      const totalShapes = 12;
      // レベル進行につれ、正解形は5->3個へ
      const T = Math.round(5 - (lvl - 1) * 2 / (totalLevels - 1));
      const counts = {};
      counts[correct] = T;

      // 残りの形を割り振り
      const remainder = totalShapes - T;
      const base = Math.floor(remainder / 3);
      let extra = remainder % 3;

      shapeTypes.forEach(s => {
        if (s === correct) return;
        let cnt = base;
        if (extra > 0) {
          cnt++;
          extra--;
        }
        counts[s] = Math.max(cnt, 1);
      });

      // 実際に positions[] を生成
      const newPositions = [];
      const containerWidth = 800;   // 仮固定
      const containerHeight = 500; // 仮固定
      // 上端60pxはレベル表示等と被らないようにする
      const topOffset = 60;
      const shapeSize = 30;

      function checkOverlap(x, y, arr) {
        for (const p of arr) {
          if (x < p.x + shapeSize &&
              x + shapeSize > p.x &&
              y < p.y + shapeSize &&
              y + shapeSize > p.y) {
            return true;
          }
        }
        return false;
      }

      Object.keys(counts).forEach(shape => {
        for (let i = 0; i < counts[shape]; i++) {
          let placed = false;
          let tries = 0;
          while (!placed && tries < 100) {
            const randX = getRandomInt(0, containerWidth - shapeSize);
            const randY = getRandomInt(topOffset, containerHeight - shapeSize);
            if (!checkOverlap(randX, randY, newPositions)) {
              newPositions.push({
                shape,
                x: randX,
                y: randY,
              });
              placed = true;
            }
            tries++;
          }
        }
      });

      setShapesPos(newPositions);
    }, [totalLevels]);

    // -----------------------------
    // GoodUIで回答ボタンをクリック
    // -----------------------------
    const handleGoodUIAnswer = (shape) => {
      if (!isSessionActive) return;
      if (isBadUI) return; // BadUIモードは無効
      checkAnswer(shape);
    };

    // -----------------------------
    // BadUIのモーダル関連
    // -----------------------------
    const { isOpen, onOpen, onClose } = useDisclosure();
    const [selectedShape, setSelectedShape] = React.useState(null);

    const handleOpenAnswerModal = () => {
      if (!isSessionActive) return;
      onOpen();
    };

    const handleChooseShapeBadUI = (s) => {
      // BadUIで選択した図形
      setSelectedShape(s);
    };

    const handleConfirmBadUI = () => {
      if (selectedShape) {
        // 確認OK→回答チェック
        checkAnswer(selectedShape);
      }
      onClose();
    };

    const handleReturnBadUI = () => {
      // "return" -> モーダル閉じるだけ
      onClose();
    };

    // -----------------------------
    // 正解/不正解チェック & レベル進行
    // -----------------------------
    const checkAnswer = (shape) => {
      if (shape === correctShape) {
        // 正解
        showToast("⭕️", "success");
        // 次レベル
        if (level < totalLevels) {
          const nextLevel = level + 1;
          setLevel(nextLevel);
          generateShapesForLevel(nextLevel);
        } else {
          // 全部終わったらセッション終了
          endSession(false);
        }
      } else {
        // 不正解 -> トースト❌
        showToast("❌", "error");
        // 不正解でもレベルは進まない(再回答)
        // BadUIなら ポップアップ表示を廃止 → 何もしない
      }
    };

    // -----------------------------
    // トースト通知
    // -----------------------------
    const showToast = (message, status) => {
      toast.closeAll(); // 連続表示を防ぐため一旦全部閉じる
      toast({
        description: message,
        status: status,
        duration: 3000,
        position: "bottom-left",
        isClosable: false
      });
    };

    // -----------------------------
    // ユーティリティ
    // -----------------------------
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    // -----------------------------
    // レンダリング
    // -----------------------------
    return (
      <Box height="100%" display="flex" flexDirection="column">
        {/* ヘッダー部分 */}
        <Box bg="gray.200" p={4}>
          <Flex alignItems="center" justifyContent="space-between">
            <Text fontWeight="bold">Shape Puzzle (Chakra UI)</Text>
            {/* プレイ時間設定 & Start */}
            {!isSessionActive && (
              <HStack>
                <Text>Play Time (min):</Text>
                <NumberInput
                  size="sm"
                  width="60px"
                  min={1}
                  max={60}
                  value={playTime}
                  onChange={handlePlayTimeChange}
                >
                  <NumberInputField />
                </NumberInput>
                <Button colorScheme="blue" onClick={startSession}>
                  Start
                </Button>
              </HStack>
            )}
            {isSessionActive && (
              <Button colorScheme="orange" onClick={handleRestart}>
                Restart
              </Button>
            )}
          </Flex>
        </Box>

        {/* メインコンテナ */}
        <Flex flex="1" position="relative" bg="white" overflow="hidden">
          {/* レベル表示 & タイマー */}
          <Box position="absolute" left="10px" top="10px" bg="whiteAlpha.700" p={2} borderRadius="md" zIndex={1}>
            <Text>Level {level} / {totalLevels}</Text>
          </Box>
          <Box position="absolute" right="10px" top="10px" bg="whiteAlpha.700" p={2} borderRadius="md" zIndex={1}>
            <Text>Time: {Math.max(timeRemaining, 0)}s</Text>
          </Box>

          {/* 図形の配置 */}
          <Center w="800px" h="500px" margin="0 auto" position="relative" bg="gray.50" mt="60px">
            {shapesPos.map((item, idx) => {
              return (
                <Box
                  key={idx}
                  className="shape-item"
                  style={{
                    left: `${item.x}px`,
                    top: `${item.y - 60}px` // 60px分ずらす（箱自体がCenter内にあるための微調整）
                  }}
                >
                  {item.shape}
                </Box>
              );
            })}
          </Center>
        </Flex>

        {/* フッター部分: GoodUI or BadUI */}
        {isSessionActive && !isBadUI && (
          <Box bg="gray.100" p={4} borderTop="1px solid #ccc">
            {/* GoodUI: 4つのボタンを中央に隣接させる */}
            <HStack justifyContent="center" spacing={4}>
              {shapeTypes.map(s => (
                <Button
                  key={s}
                  colorScheme="teal"
                  variant="solid"
                  onClick={() => handleGoodUIAnswer(s)}
                >
                  {s}
                </Button>
              ))}
            </HStack>
          </Box>
        )}

        {isSessionActive && isBadUI && (
          <Box bg="gray.100" p={4} borderTop="1px solid #ccc">
            {/* BadUI: "Answer" ボタンのみ */}
            <Center>
              <Button colorScheme="red" onClick={handleOpenAnswerModal}>
                Answer
              </Button>
            </Center>
          </Box>
        )}

        {/* BadUIのモーダル */}
        <Modal isOpen={isOpen} onClose={onClose}>
          <ModalOverlay />
          <ModalContent>
            <ModalHeader>Select the shape</ModalHeader>
            <ModalCloseButton />
            <ModalBody>
              <SimpleGrid columns={2} spacing={2}>
                {shapeTypes.map(s => (
                  <Button
                    key={s}
                    fontSize={ (s === "●" || s === "■") ? "16px" : "12px" }
                    onClick={() => handleChooseShapeBadUI(s)}
                  >
                    {s}
                  </Button>
                ))}
              </SimpleGrid>
            </ModalBody>
            <ModalFooter>
              <HStack spacing={2}>
                <Button colorScheme="blue" onClick={handleConfirmBadUI}>Confirm</Button>
                <Button variant="outline" onClick={handleReturnBadUI}>return</Button>
              </HStack>
            </ModalFooter>
          </ModalContent>
        </Modal>
      </Box>
    );
  }

  // ルートレンダリング
  const rootElement = document.getElementById("root");
  ReactDOM.render(
    <ChakraProvider>
      <ChakraPuzzleApp />
    </ChakraProvider>,
    rootElement
  );
})();
</script>
</body>
</html>
